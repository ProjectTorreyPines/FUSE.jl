#= =============== =#
#  ActorPowerNeeds  #
#= =============== =#
Base.@kwdef mutable struct FUSEparameters__ActorPowerNeeds{T<:Real} <: ParametersActor{T}
    _parent::WeakRef = WeakRef(Nothing)
    _name::Symbol = :not_set
    _time::Float64 = NaN
    model::Switch{Symbol} = Switch{Symbol}([:thermal_power_fraction, :EU_DEMO, :FUSE], "-", "Power plant electrical needs model"; default=:FUSE)
    thermal_power_fraction::Entry{T} = Entry{T}("-", "Fraction of the gross electrical power generated by the thermal cycle (if model==`:thermal_power_fraction`)")
    do_plot::Entry{Bool} = act_common_parameters(; do_plot=false)
end

mutable struct ActorPowerNeeds{D,P} <: SingleAbstractActor{D,P}
    dd::IMAS.dd{D}
    par::OverrideParameters{P,FUSEparameters__ActorPowerNeeds{P}}
    function ActorPowerNeeds(dd::IMAS.dd{D}, par::FUSEparameters__ActorPowerNeeds{P}; kw...) where {D<:Real,P<:Real}
        logging_actor_init(ActorPowerNeeds)
        par = OverrideParameters(par; kw...)
        return new{D,P}(dd, par)
    end
end

"""
    ActorPowerNeeds(dd::IMAS.dd, act::ParametersAllActors; kw...)

Power needs actor that calculates the needed power to operate the plant

  - `model = :thermal_power_fraction` simply assumes that the power to balance a plant is a fraction of the gross electrical power generated by the thermal cycle.
  - `model = :EU_DEMO` subdivides the power plant electrical needs to [:cryostat, :tritium_handling, :pumping] using  EU-DEMO numbers.
  - `model = :FUSE` subdivides power plant needs into subsystems and calculates their power needs.

!!! note

    Stores data in `dd.balance_of_plant.power_electric_plant_operation`
"""
function ActorPowerNeeds(dd::IMAS.dd, act::ParametersAllActors; kw...)
    actor = ActorPowerNeeds(dd, act.ActorPowerNeeds; kw...)
    step(actor)
    finalize(actor)
    return actor
end

function _step(actor::ActorPowerNeeds)
    dd = actor.dd
    par = actor.par

    bop = dd.balance_of_plant
    bop_electric = bop.power_electric_plant_operation
    empty!(bop_electric)
    if ismissing(bop, :time)
        bop.time = [dd.global_time]
    end

    ## heating and current drive systems
    system = :HCD
    idx = IMAS.name_2_index(bop_electric.system)[system]
    sys = resize!(bop_electric.system, "name" => string(system), "index" => idx)
    sys.power = zeros(length(bop.time))
    for (idx, hcd_system) in enumerate(intersect([:nbi, :ec_launchers, :ic_antennas, :lh_antennas], keys(dd)))
        sub_sys = resize!(sys.subsystem, "name" => string(hcd_system), "index" => idx)
        @ddtime(sub_sys.power = electricity(getproperty(dd, hcd_system)))
        sys.power .+= sub_sys.power
    end

    ## Other subsytems based on model
    if par.model == :thermal_power_fraction
        idx = IMAS.name_2_index(bop_electric.system)[:plant]
        sys = resize!(bop_electric.system, "name" => "BOP", "index" => idx)
        sys.power = par.thermal_power_fraction .* bop.power_plant.power_electric_generated

    elseif par.model == :FUSE
        # For now electrical needs same as DEMO but with self-consistent pumping
        bop_systems = [:cryostat, :tritium_handling, :pf_active]
        for system in bop_systems
            idx = IMAS.name_2_index(bop_electric.system)[system]
            sys = resize!(bop_electric.system, "name" => string(system), "index" => idx)
            @ddtime(sys.power = electricity(system))
        end

    elseif par.model == :EU_DEMO
        # More realistic DEMO numbers
        bop_systems = [:cryostat, :tritium_handling, :pf_active]
        for system in bop_systems
            idx = IMAS.name_2_index(bop_electric.system)[system]
            sys = resize!(bop_electric.system, "name" => string(system), "index" => idx)
            sys.power = electricity(system)
        end
    end
    return actor
end

function heating_and_current_drive_calc(system_unit::Any)
    power_electric_total = 0.0
    for item_unit in system_unit
        efficiencies = [getproperty(item_unit.efficiency, key) for key in IMAS.keys_no_missing(item_unit.efficiency)]
        if isempty(efficiencies)
            efficiency = 1.0
        else
            efficiency = prod(efficiencies)
        end
        power_electric_total += @ddtime(item_unit.power_launched.data) / efficiency
    end
    return power_electric_total
end

function electricity(nbi::IMAS.nbi)
    return heating_and_current_drive_calc(nbi.unit)
end

function electricity(ec_launchers::IMAS.ec_launchers)
    return heating_and_current_drive_calc(ec_launchers.beam)
end

function electricity(ic_antennas::IMAS.ic_antennas)
    return heating_and_current_drive_calc(ic_antennas.antenna)
end

function electricity(lh_antennas::IMAS.lh_antennas)
    return heating_and_current_drive_calc(lh_antennas.antenna)
end

function electricity(symbol::Symbol)
    return electricity(Val{symbol})
end

#= =================== =#
#  EU DEMO electricity  #
#= =================== =#

# Dummy functions values taken from DEMO 2017  https://iopscience.iop.org/article/10.1088/0029-5515/57/1/016011
function electricity(::Type{Val{:cryostat}})
    return 30e6 # We
end

function electricity(::Type{Val{:tritium_handling}})
    return 15e6# We
end

function electricity(::Type{Val{:pf_active}})
    return 0.0 # We    (Note this should not be a constant!)
end

#= =================== =#
#  FUSE electricity     #
#= =================== =#

function electricity(symbol::Symbol, bop::IMAS.balance_of_plant)
    return electricity(Val{symbol}, bop)
end